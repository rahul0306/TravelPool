rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function signedIn() {
      return request.auth != null;
    }

    function isOwner(uid) {
      return signedIn() && request.auth.uid == uid;
    }

    // ----------------------------
    // Trip helpers
    // ----------------------------

    // Use for READ checks (safe general checks)
    function tripNow(tripId) {
      return get(/databases/$(database)/documents/trips/$(tripId));
    }

    function isTripMember(tripId) {
      return signedIn()
        && (request.auth.uid in tripNow(tripId).data.members);
    }

    function isTripOwner(tripId) {
      return signedIn()
        && (tripNow(tripId).data.ownerId == request.auth.uid);
    }

    // Use for WRITE checks where you want the post-write state
    function tripAfter(tripId) {
      return getAfter(/databases/$(database)/documents/trips/$(tripId));
    }

    // ----------------------------
    // Trip join codes
    // ----------------------------
    match /tripJoinCodes/{code} {
      allow get, list: if signedIn();

      allow create: if signedIn()
        && request.resource.data.tripId is string
        && request.resource.data.createdBy == request.auth.uid
        && request.resource.data.createdAt is int;

      allow update, delete: if false;
    }

    // ----------------------------
    // Users (private)
    // ----------------------------
    match /users/{uid} {
      allow read, create, update: if signedIn() && request.auth.uid == uid;
      allow delete: if false;

      match /notifications/{notificationId} {
        allow read, update, delete: if isOwner(uid);

        // sender and recipient must be members of the trip AFTER the write
        allow create: if signedIn()
          && request.resource.data.uid == uid
          && request.resource.data.tripId is string
          && request.resource.data.createdAt is int
          && request.resource.data.type is string
          && request.resource.data.title is string
          && request.resource.data.body is string
          && (request.auth.uid in tripAfter(request.resource.data.tripId).data.members)
          && (uid in tripAfter(request.resource.data.tripId).data.members);
      }
    }

    // ----------------------------
    // Trips
    // ----------------------------
    match /trips/{tripId} {

      // âœ… Only trip members can read the trip doc / query it
      allow read: if signedIn() && (request.auth.uid in resource.data.members);

      // Create: creator must be owner and included in members
      allow create: if signedIn()
        && request.resource.data.ownerId == request.auth.uid
        && request.resource.data.members is list
        && (request.auth.uid in request.resource.data.members);

      // Update:
      // - Owner can update anything
      // - Non-owner can ONLY join by adding themselves to members
      allow update: if isTripOwner(tripId)
        || (
          signedIn()
          && request.resource.data.diff(resource.data).changedKeys().hasOnly(['members'])
          && !(request.auth.uid in resource.data.members)
          && (request.auth.uid in request.resource.data.members)
          && request.resource.data.members.size() == resource.data.members.size() + 1
          && request.resource.data.members.hasAll(resource.data.members)
        );

      // Delete: owner only
      allow delete: if isTripOwner(tripId);

      // ----------------------------
      // Trip members subcollection
      // ----------------------------
      match /members/{uid} {

        // Any trip member can read members list
        allow read: if isTripMember(tripId);

        // Allow creating a member doc if you are the owner, OR if you are joining the trip in the same write.
        allow create: if isTripOwner(tripId)
          || (
            signedIn()
            && request.auth.uid == uid
            && (uid in tripAfter(tripId).data.members)
            // Basic schema validation
            && request.resource.data.uid == uid
            && request.resource.data.name is string
            && request.resource.data.email is string
            && request.resource.data.role is string
            && request.resource.data.joinedAt is int
          );

        // Owner can manage anyone; member can update/delete their own doc
        allow update, delete: if isTripOwner(tripId)
          || (isTripMember(tripId) && request.auth.uid == uid);
      }

      // ----------------------------
      // Pool contributions
      // ----------------------------
      match /contributions/{contributionId} {
        allow read: if isTripMember(tripId);

        allow create: if isTripMember(tripId)
          && request.resource.data.tripId == tripId
          && request.resource.data.uid == request.auth.uid
          && request.resource.data.amountCents is int
          && request.resource.data.amountCents > 0
          && request.resource.data.createdAt is int;

        allow update, delete: if isTripOwner(tripId)
          || (isTripMember(tripId) && resource.data.uid == request.auth.uid);
      }

      // ----------------------------
      // Itinerary
      // ----------------------------
      match /itinerary/{itemId} {
        allow read, write: if isTripMember(tripId);
      }

      // ----------------------------
      // Pool expenses
      // ----------------------------
      match /expenses/{expenseId} {
        allow read: if isTripMember(tripId);

        allow create: if isTripMember(tripId)
          && request.resource.data.tripId == tripId
          && request.resource.data.amountCents is int
          && request.resource.data.amountCents > 0
          && request.resource.data.title is string
          && request.resource.data.createdAt is int
          && request.resource.data.paidByUid is string
          && (request.resource.data.paidByUid in tripAfter(tripId).data.members)
          && request.resource.data.splitBetweenUids is list
          && request.resource.data.splitBetweenUids.size() > 0
          && tripAfter(tripId).data.members.hasAll(request.resource.data.splitBetweenUids);

        allow update: if isTripOwner(tripId)
          || (isTripMember(tripId) && resource.data.paidByUid == request.auth.uid)
          || (
            isTripMember(tripId)
            && request.resource.data.diff(resource.data).changedKeys().hasOnly(['receiptUrls'])
            && request.resource.data.receiptUrls is list
          );

        allow delete: if isTripOwner(tripId)
          || (isTripMember(tripId) && resource.data.paidByUid == request.auth.uid);
      }

      // ----------------------------
      // Settlements
      // ----------------------------
      match /settlements/{settlementId} {
        allow read: if isTripMember(tripId);

        allow create: if isTripMember(tripId)
          && request.resource.data.tripId == tripId
          && request.resource.data.amountCents is int
          && request.resource.data.amountCents > 0
          && request.resource.data.createdAt is int
          && request.resource.data.fromUid == request.auth.uid
          && (request.resource.data.toUid in tripAfter(tripId).data.members);

        allow update, delete: if false;
      }

      // ----------------------------
      // Messages
      // ----------------------------
      match /messages/{messageId} {
        allow read, create: if isTripMember(tripId);
        allow update, delete: if false;
      }
    }

    // Default deny
    match /{document=**} {
      allow read, write: if false;
    }
  }
}